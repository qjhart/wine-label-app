<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-form/iron-form.html">
<link rel="import" href="../wine-label-sdk/wine-label-sdk.html">

<link rel="import" href="../iron-icons/iron-icons.html">

<!-- Leaflet for image drawing -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>

<!--
`wine-page-markup`
demo demo/index.html
-->

<dom-module id="wine-page-markup-item">
	<template>
		<style>
		 .one-item {
				 @apply(--layout-horizontal);
		 }
		</style>

	<div class="container one-item">
		<content></content>
		<!-- <paper-icon-button icon="icons:info" title="info"></paper-icon-button> -->
		<!-- <paper-icon-button icon="icons:create" title="edit"></paper-icon-button> -->
	</div>
	</template>

	<script>
    Polymer({
		is: 'wine-label-item',
		});
	</script>

</dom-module>

<dom-module id="wine-page-markup">
  <template>

    <style>
      :host {
        display: none;
      }

      :host([active]) {
        display: block;
      }

      iron-image {
        /*width:900px;
        height:512px;*/
        @apply(--wine-label-label-img);
      }

		 .label_aspect {
				 /* width within the parent.
						can be any percentage. */
				 width: 100%;
		 }
		 .label_aspect:before {
				 content: "";
				 float: left;

				 /* essentially the aspect ratio. 100% means the
						div will remain 100% as tall as it is wide, or
						square in other words.  */
				 padding-bottom: 67%;
		 }
		 /* this is a clearfix. you can use whatever
				clearfix you usually use, add
				overflow:hidden to the parent element,
				or simply float the parent container. */
		 .label_aspect:after {
				 content: "";
				 display: table;
				 clear: both;
		 }

		 .flex-item {
					@apply(--layout-flex);
			}

		 .flex-center-justified {
				 @apply(--layout-vertical);
				 @apply(--layout-center-justified);
		 }

		 .flex-horizontal {
				 @apply(--layout-horizontal);
		 }
    </style>

		<div class="page_aspect" id="mapid">
			CATALOG PAGE HERE
		</div>

    <form>
			<template is="dom-repeat" items="[[data.rows]]">
				<div class="container flex-horizontal">
					<template is="dom-repeat" items="[[item]]">
					<wine-label-item>
						<paper-input label$="[[item.type]]" value="[[item.text]]" maxlength=1056></paper-input>
					</wine-label-item>
					</template>
					</div>
				</template>

				<div class="container flex-horizontal">
					<wine-label-item>
						<paper-dropdown-menu label="Wine Color">
							<paper-listbox class="dropdown-content" attr-for-selected="value" selected="[[data.color]]">
								<paper-item value="w:Red">Red Wine</paper-item>
								<paper-item value="w:White">White Wine</paper-item>
								<paper-item value="w:Rose">Rose</paper-item>
							</paper-listbox>
						</paper-dropdown-menu>
					</wine-label-item>
					<wine-label-item>
						<paper-dropdown-menu label="Wine Type">
							<paper-listbox class="dropdown-content" attr-for-selected="value" selected="[[data.type]]">
								<paper-item value="w:Still">Still</paper-item>
								<paper-item value="w:Sparkling">Sparkling</paper-item>
								<paper-item value="w:Fortified">Fortified</paper-item>
							</paper-listbox>
						</paper-dropdown-menu>
					</wine-label-item>
				</div>
				<paper-button raised onclick="_submit(event)">Submit</paper-button>
				<paper-button raised onclick="_reset(event)">Reset</paper-button>
    </form>

  </template>

  <script>
   Polymer({

       is: 'wine-page-markup',

       properties: {
					 page_id : {
							 type : String,
							 value : '',
							 observer : '_setData'
					 },

					 active: {
							 type: Boolean,
							 value: false,
							 reflectToAttribute: true
					 },
					 data : {
							 type : Object,
							 value : function() {
									 return {};
							 },
							 observer: 'redraw'
					 },
					 map: {
							 type: Object,
							 value: null
					 }
      },

      ready : function() {
      },

			 // From GeoJSON geometry
			 // return bbox as [xmin,ymin],[xmax,ymax]]
			 geometry_bbox: function(geometry) {
					 var c1=geometry.coordinates[0][0];
					 var min=[c1[0],c1[1]];
					 var max=[c1[0],c1[1]];
					 geometry.coordinates[0].forEach(function(pt) {
							 min[0]=(min[0]<pt[0])?min[0]:pt[0];
							 min[1]=(min[1]<pt[1])?min[1]:pt[1];
							 max[0]=(max[0]>pt[0])?max[0]:pt[0];
							 max[1]=(max[1]>pt[1])?max[1]:pt[1];
					 });
					 return[min,max];
			 },

			 annotation_rc(key,annotations=this.data.annotations) {
					 var rows=this.annotations_to_rows(annotations,{keys:true});
					 for (var r=0; r<rows.length;r++) {
							 for (var c=0; c<rows[r].length;c++) {
									 if (rows[r][c] == key) {
											 return [r,c];
									 }
							 }
					 }
					 return null;
			 },

			 redraw: function() {
					 if (Object.keys(this.data).length == 0 ) {
							 return;
					 }
					 if (this.map) {
							 this.map.remove();
					 }
					 this.map = L.map(this.$.mapid, {
							 crs: L.CRS.Simple,
							 minZoom: -2
					 });

					 var map=this.map;
					 setTimeout(function(){ map.invalidateSize()}, 200);
//					 map.invalidateSize();


					 var bounds = [[0,0], [-1365,2048]];
					 var image = L.imageOverlay(this.data.image, bounds).addTo(map);
					 map.fitBounds(bounds);

					 if (this.data.annotations) {

						setTimeout(()=>{this.set('data.rows',[])},200);
						setTimeout(()=>{
							 this.set('data.rows',this.annotations_to_rows(this.data.annotations))
						},300);

							 Object.keys(this.data.annotations).forEach((k) => {
									 var a=this.data.annotations[k];
									 var an={'type':'Feature',
													 properties:{key:k,
																			 text:a.text,
																			 type:a.type,
													 },
													 geometry:a.geometry};
									 L.geoJSON(an, {
											 style: function(feature) {
													 switch (feature.properties.type) {
															 case 'other': return {color: "#ff0000"};
															 case 'vintage.date':  return {color: "tomato"};
															 case 'brandName':  return {color: "goldenrod"};
															 case 'vintage.alcohol':   return {color: "#0000ff"};
													 }
											 }
									 }).addTo(map);
							 });
					 }
			 },

      _setData : function() {
//        if( !this.wineLabelId ) return;
//        if( UCDWineSDK.collections.wines.loading ) return;

//        UCDWineSDK.collections.wines.get(this.wineLabelId, function(item){
//          if( !item ) throw new Error('Unknown wine label '+this.wineLabelId);
//          this.data = item;
//        }.bind(this));
      },

			 // edit an existing annotation
			 edit : function (key,edits={}) {
					 var fields=['type','text','geometry'];

					 // We should really limit to these types
					 var type_is_good=false;
					 var types=['color','type','country','language',
											'brandName','varietal','otherDesignation',
											'winery.name','winery.address','winery.addressQualification',
											'vintage.year','vintage.alcohol'];

					 var item = this.data.annotations[key];
					 var rc = this.annotation_rc(key);

					 // Throw Errr?
					 if (! rc) {
							 return null;
					 }

					 var rc_path='data.row.'+rc[0]+'.'+rc[1];

					 if (edits.type) {
							 types.forEach((t)=>{ if (t==edits.type) { type_is_good=true;}});
					 }
					 fields.forEach((f)=>{
							 if (edits[f]) {
									 item[f]=edits[f];
									 this.set(rc.path+'.'+f,item[f]);
							 }
					 });
					 if (edits.key) {
							 delete this.data.annotations[key];
							 this.data.annotations[edits.key]=item;
					 }
					 this.add_history('edit',key,edits);
			 },
			 // drop a notation from consideration
			 drop : function(keys,parms={history:true}) {
					 if (typeof keys !== "object") {
							 keys=[keys];
					 }
					 var i,a;
					 keys.forEach((key)=>{
							 delete this.data.annotations[key];
					 });
					 if (parms.history) {
							 this.add_history('drop',keys);
					 }
					 this.notifyPath('data.annotations.*');
			 }

    });
  </script>

</dom-module>
